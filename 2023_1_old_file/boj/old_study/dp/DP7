#11722
아쉽게도 맞추지는 못햿다.

첫 런타임에러 : 선언 코드 안옮겨서

정답은 같았으나 조건에 잘못 부합한 상태의 코드인가?



<직접짠 코드>

n = int(input())
a = list(map(int, input().split()))
dp = [1]*n
a.sort(reverse = True)


j = 1
for i in range(n-1):
    if a[i] > a[j]:
        dp[j] = max(dp[i], max(dp) + 1)
    j = j+1     
    

print(max(dp))

<해설코드> : 거의 똑같이 짰다.

n = int(input())
a = list(map(int, input().split()))
dp = [1]*n

for i in range(1, n):
    for j in range(i):
        if a[i] < a[j]:
            dp[i] = max(dp[j] + 1, dp[i])
        
print(max(dp))

<차이점> : max 메소드 조건 부분이 살짝 다르다. 내가 짠 코드는 전체 배열에서의 최댓값 + 1로 진행하기 위해서 j열을 for문으로 사용하지않고
단순 변수 증가율로만 만들었다. 하지만 조건에 부합하지 않는지 오답을 내렸다.

해설코드는 j열을 0~i-1 까지, i변수를 1~ n-1(4) 까지 굴렸다.
근데 이렇게 굴리면 나는 일일히 다 증가 시킬것이라고 생각했다. 그래서 사용하지 않았었는데 괜찮게 나왔다.

내가 짠 코드는 sort 메소드를 이용해서 내림차순으로 바꾸어서 감소하는 부분배열을 탐색이 편하도록 만들려고 짰다.



#11054

# 수열 S -> S1 < S2 < ...Sk-1 < Sk > Sk+1 > ... > SN-1 > SN

# 어떤 수를 기준으로 오름차순 내림차순을 진행하면 바이토닉 수열이다.

# {10, 20, 30, 25, 20} -> 30을 기준으로 진행되었다. (등반)

# {10, 20, 30, 40} -> 40을 기준으로 (오름차순)

# {50, 40, 25, 10} -> 50을 기준으로 (내림차순)

# {1, 2, 3, 2, 1, 2, 3, 2, 1} 어떤 기준없이 오르막내리막 오락가락이다 -> 바이토닉 X

# {10, 20, 30, 40, 20, 30} -> 오르락 내리락 오락가락 -> 바이토닉 X

# <기준>

#
n = int(input())

a = list(map(int, input().split()))

# <경우의 수>

# 1. 등반

# 2. 오름차순

# 3. 내림차순

# 4. else -> 바이토닉이 아니다 -> 0출력

# # -> 바이토닉 수열의 길이 출력

#오름차순
for i in range(1, n):
    for j in range(i):
        if a[i] > a[j]:
            dp[i] = max(dp[j] + 1, dp[i])
    
#내림차순
for i in range(1, n):
    for j in range(i):
        if a[i] < a[j]:
            dp[i] = max(dp[j]+1, dp[i])
            
#등반

for i in range(1, n):
    for j in range(i):
        if 
        elif a[i] > a[j]:
            dp[i] = max(dp[j] +1, dp[i])
        elif a[i] < a[j]:
            dp[i] = max(dp[j] +1, dp[i])
            
            
등반 경우의 수에서 헷갈렸다. 오름차순 내림차순은 다른 문제들로 숙지가 되어있지만 등반의 상황에서는 조건식과 메소드 사용에 대해서 몰랐다.
코드가 완성하지 못하고 이렇게 되면 안될까? 라는 생각으로 조건을 짜다가 말았다.

<해설>
바이토닉 수열 : 점진적인 증가와 점진적인 감소가 최대가 되는 부분을 찾기
양방향의 DP 메모라이제이션 -> https://aigong.tistory.com/386


        
        
