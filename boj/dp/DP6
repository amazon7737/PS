# DP 하면서 깨달음
1. 경우의 수를 생각한다.
2. 규칙성 파악
3. dp는 조건의 맞는 최대합을 말한다.
4. 규칙성을 토대로 dp에 조건에 맞게 정립될 반복문을 생각하면 대부분 풀린다.

#9465 (스티커문제 힘들다고 느꼈다.)

t = int(input())
for i in range(t):
  s = []
  n = int(input())
  for k in range(2):
    s.append(list(map(int, input().split())))
  for j in range(1, n):
    if j == 1:
      s[0][j] += s[1][j - 1]
      s[1][j] += s[0][j - 1]
    else:
      s[0][j] += max(s[1][j - 1], s[1][j - 2])
      s[1][j] += max(s[0][j - 1], s[0][j - 2])
  print(max(s[0][n - 1], s[1][n - 1]))
  
  
  1. 각 자리에 올 수 있는 경우의 
  
  1번 인덱스 : 왼쪽 대각선 숫자 더하기
  2번 인덱스~ : 이떄까지 최댓값을 더한 숫자를 저장하고 있는 왼쪽 대각선 숫자, 또는 그 왼쪽에 있는 숫자 2가지 경우의 수로 나눌수 있다.
  

#2156 ( 포도주 시식 -> dp문제중 제일 어렵다고 느꼈던 문제 -> 최적화된 코드를 해석하지 못해서 한달정도 생각했다.)
if N == 1:
    print(grape[0])
elif N == 2:
    print(grape[0] + grape[1])
else:
    dp[0] = grape[0]
    dp[1] = grape[0] + grape[1]
    dp[2] = grape[2] + max(grape[1], grape[0])
    for i in range(3, N):
        dp[i] = max(dp[i-2] + grape[i], dp[i-3] + grape[i-1] + grape[i], dp[i-4] + grape[i-1] + grape[i])
        
    print(max(dp))
    

# 11053번
x = int(input())

arr = list(map(int, input().split()))

dp = [1 for i in range(x)]

for i in range(x):
    for j in range(i):
        if arr[i] > arr[j]:
            dp[i] = max(dp[i], dp[j]+1)

print(max(dp))


<중첩 for문 돌리면서 헷갈렸던 부분을 짜봣다>

for i in range(6): # i 한번 고정하고 j 순환 돌리고 돌아옴
    print("나는 i", i)
    for j in range(i): # i-1 까지 감 + i = 0, 1 -> j 생략
        print("나는 j", j)

#11055

a = [1, 100, 2, 50, 60, 3, 5, 6, 7, 8]
dp = [0]*len(a)
dp[0] = a[0]
dp[1] = a[0] + a[1]

for i in range(2, len(a)):
    dp[i] = a[i]
    for j in range(i):
        if a[j] < a[i]:
            dp[i] += a[j]
            
print(max(dp))

